<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Javascript | ele-alien-前端常用的工具库</title>
    <meta name="description" content="element 超强组件组合">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.e45d7faa.css" as="style"><link rel="preload" href="/assets/js/app.baf443ff.js" as="script"><link rel="preload" href="/assets/js/37.ee884d88.js" as="script"><link rel="prefetch" href="/assets/js/10.7bc5914e.js"><link rel="prefetch" href="/assets/js/11.fcd42ad7.js"><link rel="prefetch" href="/assets/js/12.624769de.js"><link rel="prefetch" href="/assets/js/13.1f668162.js"><link rel="prefetch" href="/assets/js/14.6497d5d5.js"><link rel="prefetch" href="/assets/js/15.edf86689.js"><link rel="prefetch" href="/assets/js/16.c1781997.js"><link rel="prefetch" href="/assets/js/17.5acc6bc1.js"><link rel="prefetch" href="/assets/js/18.41d31106.js"><link rel="prefetch" href="/assets/js/19.1e4b3ed0.js"><link rel="prefetch" href="/assets/js/2.045ac2c9.js"><link rel="prefetch" href="/assets/js/20.63344807.js"><link rel="prefetch" href="/assets/js/21.b08c4c81.js"><link rel="prefetch" href="/assets/js/22.a07f77f3.js"><link rel="prefetch" href="/assets/js/23.26ccb0bb.js"><link rel="prefetch" href="/assets/js/24.a2bd4e22.js"><link rel="prefetch" href="/assets/js/25.d3327f1a.js"><link rel="prefetch" href="/assets/js/26.632fa2e1.js"><link rel="prefetch" href="/assets/js/27.4fa183cb.js"><link rel="prefetch" href="/assets/js/28.60a13d72.js"><link rel="prefetch" href="/assets/js/29.5d420210.js"><link rel="prefetch" href="/assets/js/3.099a80fc.js"><link rel="prefetch" href="/assets/js/30.3bd21622.js"><link rel="prefetch" href="/assets/js/31.eb738cb4.js"><link rel="prefetch" href="/assets/js/32.6594e108.js"><link rel="prefetch" href="/assets/js/33.dba77b64.js"><link rel="prefetch" href="/assets/js/34.03441465.js"><link rel="prefetch" href="/assets/js/35.5acce582.js"><link rel="prefetch" href="/assets/js/36.f87d97b7.js"><link rel="prefetch" href="/assets/js/38.c926c3ad.js"><link rel="prefetch" href="/assets/js/39.5c98bfdb.js"><link rel="prefetch" href="/assets/js/4.3c63cb6f.js"><link rel="prefetch" href="/assets/js/40.97ccf1cf.js"><link rel="prefetch" href="/assets/js/41.97d753a6.js"><link rel="prefetch" href="/assets/js/42.f7476e73.js"><link rel="prefetch" href="/assets/js/43.21336408.js"><link rel="prefetch" href="/assets/js/44.f12e160b.js"><link rel="prefetch" href="/assets/js/45.6ae13074.js"><link rel="prefetch" href="/assets/js/46.eb362da8.js"><link rel="prefetch" href="/assets/js/47.63e43932.js"><link rel="prefetch" href="/assets/js/48.96a0993b.js"><link rel="prefetch" href="/assets/js/49.0d28f039.js"><link rel="prefetch" href="/assets/js/5.a48cdbcb.js"><link rel="prefetch" href="/assets/js/50.d32db989.js"><link rel="prefetch" href="/assets/js/51.71dd4a03.js"><link rel="prefetch" href="/assets/js/52.8804f3c0.js"><link rel="prefetch" href="/assets/js/53.35a7de1a.js"><link rel="prefetch" href="/assets/js/54.a363b260.js"><link rel="prefetch" href="/assets/js/55.3fd79e4a.js"><link rel="prefetch" href="/assets/js/56.b646865f.js"><link rel="prefetch" href="/assets/js/57.d613c9c2.js"><link rel="prefetch" href="/assets/js/58.4100fc2b.js"><link rel="prefetch" href="/assets/js/59.1a902910.js"><link rel="prefetch" href="/assets/js/6.5a0337e4.js"><link rel="prefetch" href="/assets/js/60.a7fe9555.js"><link rel="prefetch" href="/assets/js/61.39d2c17b.js"><link rel="prefetch" href="/assets/js/62.4ee50e22.js"><link rel="prefetch" href="/assets/js/63.e552d709.js"><link rel="prefetch" href="/assets/js/64.69999e6e.js"><link rel="prefetch" href="/assets/js/65.3e6eb8ac.js"><link rel="prefetch" href="/assets/js/66.52e9f166.js"><link rel="prefetch" href="/assets/js/67.b0243212.js"><link rel="prefetch" href="/assets/js/68.dfc9afbc.js"><link rel="prefetch" href="/assets/js/69.4f6eb02e.js"><link rel="prefetch" href="/assets/js/7.7edf5fc6.js"><link rel="prefetch" href="/assets/js/8.609747e7.js"><link rel="prefetch" href="/assets/js/9.6f41a2ca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e45d7faa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">ele-alien-前端常用的工具库</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">欢迎光临</a></div><div class="nav-item"><a href="/alien-commponent/" class="nav-link">超强组件</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端工具</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/repository/" class="nav-link">开源项目</a></li><li class="dropdown-item"><!----> <a href="/website/" class="nav-link">前端网址</a></li><li class="dropdown-item"><!----> <a href="/code/" class="nav-link">代码片段</a></li><li class="dropdown-item"><!----> <a href="/webpack/" class="nav-link">Webpack</a></li></ul></div></div><div class="nav-item"><a href="/article/" class="nav-link">热门文章</a></div> <a href="https://github.com/jian22446688/ele-alien" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">欢迎光临</a></div><div class="nav-item"><a href="/alien-commponent/" class="nav-link">超强组件</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端工具</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/repository/" class="nav-link">开源项目</a></li><li class="dropdown-item"><!----> <a href="/website/" class="nav-link">前端网址</a></li><li class="dropdown-item"><!----> <a href="/code/" class="nav-link">代码片段</a></li><li class="dropdown-item"><!----> <a href="/webpack/" class="nav-link">Webpack</a></li></ul></div></div><div class="nav-item"><a href="/article/" class="nav-link">热门文章</a></div> <a href="https://github.com/jian22446688/ele-alien" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Blog</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/blog/performance .html" class="sidebar-link">前端性能监控</a></li><li><a href="/blog/cs.html" class="sidebar-link">CS</a></li><li><a href="/blog/fe.html" class="sidebar-link">前端</a></li><li><a href="/blog/google-developer.html" class="sidebar-link">读谷歌开发指南</a></li><li><a href="/blog/js.html" class="active sidebar-link">Javascript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#queryselectorall-getelementsby-区别？" class="sidebar-link">querySelectorAll getElementsBy 区别？</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#nodelist-和-htmlcollection-之间的关系？" class="sidebar-link">NodeList 和 HTMLCollection 之间的关系？</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#_1-2-3-map-parseint-坑" class="sidebar-link">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 坑</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#省略参数引发的-bug" class="sidebar-link">省略参数引发的 bug</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#多余逗号引发的错误" class="sidebar-link">多余逗号引发的错误</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#js-中的逗号" class="sidebar-link">js 中的逗号</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#document-documentelement-与-document-body-区别" class="sidebar-link">document.documentElement 与 document.body 区别</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#sort" class="sidebar-link">sort</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#codepointat-vs-charcodeat" class="sidebar-link">codePointAt vs charCodeAt</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#switch-作用域" class="sidebar-link">switch 作用域</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#div-如何监听-keydown-事件" class="sidebar-link">div 如何监听 keydown 事件</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#console-log-的坑" class="sidebar-link">console.log 的坑</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#try-catch-的-finally-坑" class="sidebar-link">try catch 的 finally 坑</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#atob-方法解码中文字符" class="sidebar-link">atob 方法解码中文字符</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#safari-下-date-的坑" class="sidebar-link">Safari 下 Date 的坑</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#e-target-与-e-currenttarget-的区别" class="sidebar-link">e.target 与 e.currentTarget 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#函数变量必填校验" class="sidebar-link">函数变量必填校验</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#前端错误处理" class="sidebar-link">前端错误处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#有哪些错误需要处理" class="sidebar-link">有哪些错误需要处理</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#try-catch" class="sidebar-link">Try Catch</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#window-onerror" class="sidebar-link">window.onerror</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#window-addeventlistener" class="sidebar-link">window.addEventListener</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#promise-catch" class="sidebar-link">Promise Catch</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#vue-errorhandler" class="sidebar-link">VUE errorHandler</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#react-异常捕获" class="sidebar-link">React 异常捕获</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#崩溃和卡顿" class="sidebar-link">崩溃和卡顿</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#insertbefore-坑" class="sidebar-link">insertBefore 坑</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#为什么前端监控要用-gif-打点" class="sidebar-link">为什么前端监控要用 GIF 打点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#主要原因" class="sidebar-link">主要原因</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#使用方式" class="sidebar-link">使用方式</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#其它方案" class="sidebar-link">其它方案</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#object-create-null-vs" class="sidebar-link">Object.create(null) vs {}</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#hasownproperty" class="sidebar-link">hasOwnProperty</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#valueof" class="sidebar-link">valueOf</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#tostring、isprototypeof-和-propertyisenumerable" class="sidebar-link">toString、isPrototypeOf 和 propertyIsEnumerable</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#结论" class="sidebar-link">结论</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#async-await-with-foreach" class="sidebar-link">async/await with forEach()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#new-date-在-safari-的坑" class="sidebar-link">new Date 在 safari 的坑</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#获取元素宽度" class="sidebar-link">获取元素宽度</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#我使用-async-await-而不使用-promises-的六个理由" class="sidebar-link">我使用 Async/Await 而不使用 Promises 的六个理由</a></li></ul></li><li><a href="/blog/other.html" class="sidebar-link">Other</a></li><li><a href="/blog/es6.html" class="sidebar-link">ES6</a></li><li><a href="/blog/product.html" class="sidebar-link">产品</a></li><li><a href="/blog/" class="sidebar-link">前言</a></li><li><a href="/blog/talk.html" class="sidebar-link">Talk</a></li><li><a href="/blog/vue.html" class="sidebar-link">Vue</a></li><li><a href="/blog/webpack.html" class="sidebar-link">Webpack</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="javascript"><a href="#javascript" aria-hidden="true" class="header-anchor">#</a> Javascript</h1> <h2 id="queryselectorall-getelementsby-区别？"><a href="#queryselectorall-getelementsby-区别？" aria-hidden="true" class="header-anchor">#</a> querySelectorAll getElementsBy 区别？</h2> <blockquote><p>2018-07-04</p></blockquote> <ul><li>浏览器兼容</li></ul> <p>querySelectorAll 已被 IE 8+、FF 3.5+、Safari 3.1+、Chrome 和 Opera 10+ 良好支持 。getElementsBy 系列，以最迟添加到规范中的 getElementsByClassName 为例，IE 9+、FF 3 +、Safari 3.1+、Chrome 和 Opera 9+ 都已经支持该方法了。</p> <ul><li>接收参数</li></ul> <p>querySelectorAll 方法接收的参数是一个 CSS 选择符。而 getElementsBy 系列接收的参数只能是单一的 className、tagName 和 name。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> c1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'.b1 .c'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> c2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> c3 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'b2'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>返回值</li></ul> <p>大部分人都知道，querySelectorAll 返回的是一个 Static Node List，而 getElementsBy 系列的返回的是一个 Live Node List。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token comment">// Demo 1</span>
<span class="token keyword">var</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    lis <span class="token operator">=</span> ul<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    ul<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span> <span class="token comment">//5</span>

<span class="token comment">// Demo 2</span>
<span class="token keyword">var</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    lis <span class="token operator">=</span> ul<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    ul<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lis<span class="token punctuation">)</span> <span class="token comment">//5+2</span>

</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>Demo 1 中的 lis 是一个静态的 Node List，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。</p> <p>Demo 2 中的 lis 是一个动态的 Node List， 每一次调用 lis 都会重新对文档进行查询，导致无限循环的问题。</p> <p>但为什么要这样设计呢？
其实，在 W3C 规范中对 querySelectorAll 方法有明确规定</p> <blockquote><p>The NodeList object returned by the querySelectorAll() method must be static ([DOM], section 8).</p></blockquote> <p>那什么是 NodeList 呢？</p> <blockquote><p>The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.</p></blockquote> <p>所以，NodeList 本质上是一个动态的 Node 集合，只是规范中对 querySelectorAll 有明确要求，规定其必须返回一个静态的 NodeList 对象。</p> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// return &quot;[object NodeList]&quot;</span>
document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// return &quot;[object HTMLCollection]&quot;</span>
</code></pre></div><p>这里又多了一个 HTMLCollection 对象出来，那 HTMLCollection 又是什么？</p> <p>实际上，HTMLCollection 和 NodeList 十分相似，都是一个动态的元素集合，每次访问都需要重新对文档进行查询。两者的本质上差别在于，HTMLCollection 是属于 Document Object Model HTML 规范，而 NodeList 属于 Document Object Model Core 规范。这样说有点难理解，看看下面的例子会比较好理解</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  lis1 <span class="token operator">=</span> ul<span class="token punctuation">.</span>childNodes<span class="token punctuation">,</span>
  lis2 <span class="token operator">=</span> ul<span class="token punctuation">.</span>children
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lis1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lis1<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// &quot;[object NodeList]&quot; 11</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lis2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lis2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// &quot;[object HTMLCollection]&quot; 4</span>
</code></pre></div><p>NodeList 对象会包含文档中的所有节点，如 Element、Text 和 Comment 等。HTMLCollection 对象只会包含文档中的 Element 节点。另外，HTMLCollection 对象比 NodeList 对象 多提供了一个 namedItem 方法。所以在现代浏览器中，querySelectorAll 的返回值是一个静态的 NodeList 对象，而 getElementsBy 系列的返回值实际上是一个 HTMLCollection 对象 。</p> <p><a href="https://www.zhihu.com/question/24702250" target="_blank" rel="noopener noreferrer">参照文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="nodelist-和-htmlcollection-之间的关系？"><a href="#nodelist-和-htmlcollection-之间的关系？" aria-hidden="true" class="header-anchor">#</a> NodeList 和 HTMLCollection 之间的关系？</h2> <blockquote><p>2018-07-04</p></blockquote> <p>历史上的 DOM 集合接口。主要不同在于 <code>HTMLCollection</code>是元素集合而 NodeList 是节点集合（即可以包含元素，也可以包含文本节点）。所以 <code>node.childNodes</code> 返回 <code>NodeList</code>，而 <code>node.children</code> 和 <code>node.getElementsByXXX</code> 返回 <code>HTMLCollection</code> 。</p> <p>唯一要注意的是 <code>querySelectorAll</code> 返回的虽然是 <code>NodeList</code> ，但是实际上是元素集合，并且是静态的（其他接口返回的 <code>HTMLCollection</code> 和 <code>NodeList</code> 都是 live 的）。</p> <p>Both interfaces are collections of DOM nodes. They differ in the methods they provide and in the type of nodes they can contain. While a NodeList can contain any node type, an HTMLCollection is supposed to only contain Element nodes.
An HTMLCollection provides the same methods as a NodeList and additionally a method called namedItem.</p> <p>Collections are always used when access has to be provided to multiple nodes, e.g. most selector methods (such as getElementsByTagName) return multiple nodes or getting a reference to all children (element.childNodes).</p> <h2 id="_1-2-3-map-parseint-坑"><a href="#_1-2-3-map-parseint-坑" aria-hidden="true" class="header-anchor">#</a> [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 坑</h2> <blockquote><p>2018-07-05</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>
</code></pre></div><p>第一反应都觉得结果会是 <code>[1,2,3]</code></p> <p>但实际结果却是 <code>[1, NaN, NaN]</code></p> <p>这是为什么呢？主要是 <code>map</code> 这个方法在调用 <code>callback</code>函数时，会给它传递三个参数:</p> <ul><li>当前正在遍历的元素</li> <li>元素索引</li> <li>原数组本身</li></ul> <p>也是就是说如上代码其实等同于</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>这样就直观的解释了上面的答案是怎么产生得了。因为 <code>parseInt</code> 会接受两个参数：参数和进制数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 实际代码运算等于如下</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// NaN</span>
</code></pre></div><p>所以为了避免这个坑，平时写 <code>map</code> 还是不要偷懒了，完整的写法才更直观并且更容易维护。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">str</span> <span class="token operator">=&gt;</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="省略参数引发的-bug"><a href="#省略参数引发的-bug" aria-hidden="true" class="header-anchor">#</a> 省略参数引发的 bug</h2> <blockquote><p>2018-07-12</p></blockquote> <p>省略参数是 es6 之后提供的一个很好用也非常常用的功能。但还是有一些细节值得注意，不然一不小心就会出现 bug。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">num <span class="token operator">=</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// (num is set to 1)</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token comment">// (num is set to 1 too)</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment">// (num is set to '')</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// (num is set to null)</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// (num is set to false)</span>
</code></pre></div><p>如上面 demo 所示，只有参数没传或者是 <code>undefined</code> 是才会生效，其它情况默认参数并不会起作用。</p> <p>所以有的时候你传入了<code>''</code>空字符串是不行的，还需要自己手动判断一下。</p> <p><code>str = str || defalutString</code></p> <p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">99</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">p <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 100</span>

x <span class="token operator">=</span> <span class="token number">100</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 101</span>
</code></pre></div><p>上面代码中，参数 p 的默认值是 x + 1。这时，每次调用函数 foo，都会重新计算 x + 1，而不是默认 p 等于 100。</p> <h2 id="多余逗号引发的错误"><a href="#多余逗号引发的错误" aria-hidden="true" class="header-anchor">#</a> 多余逗号引发的错误</h2> <blockquote><p>2018-07-12</p></blockquote> <p>刚入前端的时候看错误日志，<code>ie</code> 的错误日志特别多，一直没找到原因，后来发现是 JSON 最后一组键值后多逗号。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 所有浏览器都正常</span>
<span class="token keyword">var</span> json_normal <span class="token operator">=</span> <span class="token punctuation">{</span>
  id<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> <span class="token string">&quot;John&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// ie 报错，其它游览器正常</span>
<span class="token keyword">var</span> json_error <span class="token operator">=</span> <span class="token punctuation">{</span>
  id<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>好在现在有了 <code>eslint</code> 或者 <code>preitter</code>这种工具，这种错误很少会再发生了。</p> <h2 id="js-中的逗号"><a href="#js-中的逗号" aria-hidden="true" class="header-anchor">#</a> js 中的逗号</h2> <blockquote><p>2018-07-13</p></blockquote> <p>最近有一个小朋友写了如下一段代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token operator">++</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>很多人一下子可能会一脸懵逼。</p> <p>但看一下 <a href="Web">MDN 文档</a> 就很清楚了</p> <blockquote><p>逗号操作符 对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</p></blockquote> <p>举个例子</p> <p><code>var a=(1+1,2+2,3+3);</code> 结果就是 6。 <code>3+3</code></p> <p>但在函数中，比如比 <code>Math.max(x,y,z)</code>。这里的逗号就是分隔函数参数。</p> <p>还有声明变量时，<code>var a=1,b=2,c=3</code>。这里的逗号也是起分隔的作用。</p> <p>再举一个例子大家应该就理解了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token comment">//输出10而不是8  函数接收第一个参数,也说明逗号级别比较低</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 输出8 ()是返回了,相当于隐藏了return 所以返回最右边操作数的值</span>
</code></pre></div><p>其实最常见的运用场景就是平时经常的<code>for</code>循坏</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h2 id="document-documentelement-与-document-body-区别"><a href="#document-documentelement-与-document-body-区别" aria-hidden="true" class="header-anchor">#</a> document.documentElement 与 document.body 区别</h2> <blockquote><p>2018-08-13</p></blockquote> <p>在前端开发中，我们经常需要获取网页中滚动条滚过的长度，获取该值的方式一般通过<code>scrollTop</code>属性，如：<code>document.body.scrollTop</code>，或者<code>document.documentElement.scrollTop</code>，这两者都是经常用来获取文档滚动条滚过长度值的方式，他们又有什么区别呢？</p> <p>之前一直没注意，只到有一天发现了一个 bug:<code>document.body.scrollTop</code> 拿到的值一直是 0。</p> <p>在这个之前我们先来了解一下 <code>&lt;!DOCTYPE HTML&gt;</code>是干嘛的？为什么每个页面都需要加上这段声明。</p> <blockquote><p>doctype 声明不属于 HTML 标签，它是一条指令，告诉浏览器编写页面所用的标记的版本。
这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode" target="_blank" rel="noopener noreferrer">怪异模式(兼容模式)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”的渲染模式。<code>&lt;!DOCTYPE html&gt;</code> 能确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p></blockquote> <p><code>document.documentElement</code> 与 <code>document.body</code></p> <ul><li>document 代表的是整个文档(对于一个网页来说包括整个网页结构)</li> <li>document.documentElement 是整个文档节点树的根节点，在网页中即 html 标签</li> <li>document.body 是整个文档 DOM 节点树里的 body 节点，网页中即为 body 标签元素</li></ul> <p>但在标准模式下<code>document.body.scrollTop</code>是无效的。</p> <blockquote><p>从 Chrome 61 开始，标准模式中 document.scrollingElement 已被修正为 document.documentElement。换句话说，这个版本开始标准模式中 document.body.scrollTop 始终都等于 0。</p></blockquote> <p>所以这里建议使用兼容写法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> scrollTop <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>
  window<span class="token punctuation">.</span>pageYOffset<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop<span class="token punctuation">,</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop
<span class="token punctuation">)</span>
</code></pre></div><p>或者</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getBodyScrollTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span>
    document<span class="token punctuation">.</span>documentElement <span class="token operator">||</span> document<span class="token punctuation">.</span>scrollingElement <span class="token operator">||</span> document<span class="token punctuation">.</span>body
  <span class="token keyword">return</span> el<span class="token punctuation">.</span>scrollTop
<span class="token punctuation">}</span>
</code></pre></div><p><strong>每当这时候我就有一些怀念<code>jQuery</code>了</strong>。</p> <h2 id="sort"><a href="#sort" aria-hidden="true" class="header-anchor">#</a> sort</h2> <blockquote><p>2018-08-14</p></blockquote> <p><code>Array.sort</code>这方法一段时间不用就忘了规则是啥了。。。</p> <p>先举一些最简单例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">782</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">]</span>
array<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// =&gt; [0, 1, 2, 2, 29, 3, 3, 34, 7, 7, 782, 8]</span>
</code></pre></div><p>默认情况下，<code>sort</code>是按照<code>Unicode code points</code>排序的，换而言之，先回比较首个字符的 code point，若相同的情况下依次位数比下去。</p> <p>所以很多时候我们需要自定义 sort 的规则。最常见的操作：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">782</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">]</span>
array<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> pre <span class="token operator">-</span> next<span class="token punctuation">)</span>
<span class="token comment">// =&gt; [0, 1, 2, 2, 3, 3, 7, 7, 8, 29, 34, 782]</span>
</code></pre></div><p>其实它的规则很简单，你想让 next 和 pre 换位子就返回一个<code>&gt;0</code>的值，其它情况位置不变，即返回<code>&lt;=0</code>的值。</p> <p>所以我们可以让某些特定数字排在第一位，其它顺序不变：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>

arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">p<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n <span class="token operator">===</span> <span class="token number">3</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// =&gt; [3, 1, 2, 4, 5]</span>
</code></pre></div><h2 id="codepointat-vs-charcodeat"><a href="#codepointat-vs-charcodeat" aria-hidden="true" class="header-anchor">#</a> codePointAt vs charCodeAt</h2> <blockquote><p>2018-08-14</p></blockquote> <p>JavaScript 允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p> <p>但是，这种表示法只限于码点在\u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">'\uD842\uDFB7'</span>
<span class="token comment">// &quot;𠮷&quot;</span>
</code></pre></div><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">'𠮷'</span>

s<span class="token punctuation">.</span>length <span class="token comment">// 2</span>
s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// ''</span>
s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// ''</span>
s<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 55362</span>
s<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 57271</span>
</code></pre></div><p>所以 ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">'𠮷'</span><span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//134071</span>
</code></pre></div><p>总之，codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。</p> <h2 id="switch-作用域"><a href="#switch-作用域" aria-hidden="true" class="header-anchor">#</a> switch 作用域</h2> <p>其实我们经常会忽略一个点，switch case 是共用一个作用域的。</p> <p>比如如下代码就会抛出重复定义的错误：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>
    <span class="token keyword">let</span> foo
    <span class="token keyword">break</span>

  <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>
    <span class="token keyword">let</span> foo <span class="token comment">// 重复定义引起TypeError</span>
    <span class="token keyword">break</span>
<span class="token punctuation">}</span>
</code></pre></div><p>解决方案也很简单，我们给每一个 case 加上一个 bracket 就可以了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> foo
    <span class="token keyword">break</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> foo <span class="token comment">// 重复定义引起TypeError</span>
    <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="div-如何监听-keydown-事件"><a href="#div-如何监听-keydown-事件" aria-hidden="true" class="header-anchor">#</a> div 如何监听 keydown 事件</h2> <blockquote><p>2018-09-10</p></blockquote> <p>之前有一个人问我，为什么他监听了一个 div 的 keydown 事件，为什么没有用？
我看了一下代码发现的确没有写错？但为什么就不触发呢？</p> <p>后来查阅了一下文档</p> <blockquote><p>Focused element processing the key event, root element if no suitable input element focused</p></blockquote> <p>发现只有能被 focus 的元素才能出发键盘事件，所以 div 也就不能触发 keydown 事件了。</p> <p>那怎么才能让 div 支持呢？</p> <p>答案是 <code>tabindex</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/tabindex" target="_blank" rel="noopener noreferrer">mdn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。它表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素。</p> <p>这样一来我们就能愉快的使用<code>keydown</code>事件了。</p> <h2 id="console-log-的坑"><a href="#console-log-的坑" aria-hidden="true" class="header-anchor">#</a> console.log 的坑</h2> <blockquote><p>2018-09-18</p></blockquote> <p>console.log 应该是大部分程序员每天都没使用的函数，有时候觉得打断点太麻烦。但其实也是有一些小坑的。我们直接来举一个例子来看：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
a<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>

<span class="token comment">// 输出</span>
<span class="token comment">// {test:1}</span>
<span class="token comment">// {test:1}</span>
</code></pre></div><p>大部分人会认为第一个输出的应该是一个空对象，是 a 对象的一个快照，但结果并不是这样的。
两次输出都是<code>{test:1}</code>。</p> <p>同理数组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>

<span class="token comment">// 输出</span>
<span class="token comment">// [1]</span>
<span class="token comment">// [1]</span>
</code></pre></div><p>这就很明显了，在<code>console.log</code>一些复杂数据类型的时候，浏览器只是保存了一个引用而已，并不是打印执行时的结果。所以当你在控制台查看的时候是这个值经过了多次操作后，当前最终结果。所以打印复杂类型值的时候要注意一下，打印出来的值是不一定准确的。</p> <p>但部分情况是问题不大的，当真遇到时就很蛋疼了，最简单的方法序列化一下<code>console.log(JSON.parse(JSON.stringify(obj)))</code>。其实就是深拷贝一下。</p> <h2 id="try-catch-的-finally-坑"><a href="#try-catch-的-finally-坑" aria-hidden="true" class="header-anchor">#</a> try catch 的 finally 坑</h2> <blockquote><p>2018-09-24</p></blockquote> <p>try...catch 的 finally 可能很多人都没有使用过，它其实和 promise 中的 finally 很类似。 见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch" target="_blank" rel="noopener noreferrer">MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>它无论是否有异常它都会执行。
常见的操作就是 将关闭弹窗或者 loading</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  xxx
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  xxx
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>loading <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但其实它也是有一个小坑的。我们先看如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">'ok'</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">'error'</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'finally'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">'finally'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>我们发现最终输出了<code>finally</code>。因为这个语句只会有一个 return，finally 中的 return 覆盖了之前的定义。而且 return 会被放在最后执行。<a href="https://stackoverflow.com/questions/3837994/why-does-a-return-in-finally-override-try" target="_blank" rel="noopener noreferrer">详情见<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>可以改写成如下写法：</p> <div class="language-js extra-class"><pre class="language-js"><code>ar <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> res<span class="token operator">=</span><span class="token string">''</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    res<span class="token operator">=</span><span class="token string">'ok'</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
    res<span class="token operator">=</span><span class="token string">'error'</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>不过最好还是和 promise 中的 finally 一样，在里面做一些没有副作用的事情。免得发生一些 bug。</p> <h2 id="atob-方法解码中文字符"><a href="#atob-方法解码中文字符" aria-hidden="true" class="header-anchor">#</a> atob 方法解码中文字符</h2> <blockquote><p>2018-10-11</p></blockquote> <p>由于一些网络通讯协议的限制,你必须使用 window.btoa() 方法对原数据进行编码后，才能进行发送。接收方使用相当于 window.atob() 的方法对接受到的 base64 数据进行解码,得到原数据。</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">btoa</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token comment">// &quot;Zm9v&quot;</span>

window<span class="token punctuation">.</span><span class="token function">atob</span><span class="token punctuation">(</span><span class="token string">'Zm9v'</span><span class="token punctuation">)</span>
<span class="token comment">// &quot;foo&quot;</span>
</code></pre></div><p>atob 这个方法名称乍一看，很奇怪，不知道这个单词什么意思。我们可以理解为 A to B，也就是从 A 到 B。</p> <p>atob 表示 Base64 字符 to 普通字符，也就是 Base64 解码。</p> <p>当你在 Chrome console 中执行 <code>window.btoa('中文')</code>会发下会报错。</p> <p><code>Uncaught DOMException: Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.</code></p> <p>这时候我们可以借助 <code>encodeURIComponent</code> 和 <code>decodeURIComponent</code> 转义非中文字符。</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">btoa</span><span class="token punctuation">(</span><span class="token function">encodeURIComponent</span><span class="token punctuation">(</span><span class="token string">'中文'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// ('JUU0JUI4JUFEJUU2JTk2JTg3')</span>

<span class="token function">decodeURIComponent</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">atob</span><span class="token punctuation">(</span><span class="token string">'JUU0JUI4JUFEJUU2JTk2JTg3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// &quot;中文&quot;</span>
</code></pre></div><h2 id="safari-下-date-的坑"><a href="#safari-下-date-的坑" aria-hidden="true" class="header-anchor">#</a> Safari 下 Date 的坑</h2> <blockquote><p>2018-10-16</p></blockquote> <p>在 使用 Date 相关 api 的时候要牢记一个坑，就是 Safari 对一些时间格式是不支持的。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>Date<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'2018-10-16 12:00:00'</span><span class="token punctuation">)</span>
<span class="token comment">// 1539662400000 -- 在Chrome 下</span>
<span class="token comment">// NaN -- 在Safari下</span>
</code></pre></div><p>问题就出在 Safari 对于这个格式 YYYY-MM-DD HH:MM:SS 无法解析，Safari 要求 Date.parse()或 Date()转换日期的字符串需要满足 RFC2822 或 ISO 8601 定义的格式。不过我们可以将其转化为 YYYY/MM/DD HH:MM:SS</p> <div class="language-js extra-class"><pre class="language-js"><code>Date<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">'2018-10-16 12:00:00'</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/-/g</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>相关<a href="https://stackoverflow.com/questions/4310953/invalid-date-in-safari" target="_blank" rel="noopener noreferrer">stackoverflow<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="e-target-与-e-currenttarget-的区别"><a href="#e-target-与-e-currenttarget-的区别" aria-hidden="true" class="header-anchor">#</a> e.target 与 e.currentTarget 的区别</h2> <blockquote><p>2018-10-24</p></blockquote> <p>有一次在面试的时候问了事件委托的题目，面试人说了一个 currentTarget，突然发现<code>target</code>和<code>currentTarget</code>的区别我好像有些忘记了，垃圾 js，太多相似的 api 和属性了。</p> <p>首先我们来看一下 MDN 上对它们的解释</p> <ul><li>target：一个触发事件的对象的引用， 当事件处理程序在事件的冒泡或捕获阶段被调用时。</li> <li>currentTarget： 当事件遍历 DOM 时，标识事件的当前目标。它总是引用事件处理程序附加到的元素，而不是 event.target，event.target 标识事件发生的元素。</li></ul> <p>可能还是很抽象 ，这里提供一个在线<a href="https://jsbin.com/xekebepaqi/edit?html,js,console,output" target="_blank" rel="noopener noreferrer">demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>也就是说，currentTarget 始终是监听事件者，而 target 是事件的真正发出者。</p> <h2 id="函数变量必填校验"><a href="#函数变量必填校验" aria-hidden="true" class="header-anchor">#</a> 函数变量必填校验</h2> <blockquote><p>2018-11-02</p></blockquote> <p>这里分享一个平时写 ES6 的时候一个小技巧。如何简单的校验并强制在使用这个函数时必须传参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">isRequired</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Missing parameter'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">something <span class="token operator">=</span> <span class="token function">isRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span>
  <span class="token keyword">return</span> something
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Error:Missing parameter</span>
</code></pre></div><h2 id="前端错误处理"><a href="#前端错误处理" aria-hidden="true" class="header-anchor">#</a> 前端错误处理</h2> <blockquote><p>2018-12-04</p></blockquote> <p>错误处理对于任何前端来说都是必不可少的。任何人写代码都避免不了会有 bug，而且很多 bug 也不是测试用例能完全覆盖的，如果我们没有一个完整的错误处理和错误收集的系统，我们都无法知道我们有 bug，不仅如此，很多 bug 也不一定是前端的问题，比如某个接口返回的数据格式不对了或者少字段了，亦或是在某个特定的浏览器型号上才有的问题等等。而且有了错误处理和收集，我们也才能更好的通过错误栈来还原这个问题。</p> <h3 id="有哪些错误需要处理"><a href="#有哪些错误需要处理" aria-hidden="true" class="header-anchor">#</a> 有哪些错误需要处理</h3> <ul><li>JS 语法错误、代码异常</li> <li>请求错误</li> <li>静态资源加载异常</li> <li>Promise 异常</li> <li>页面崩溃和卡顿</li></ul> <h3 id="try-catch"><a href="#try-catch" aria-hidden="true" class="header-anchor">#</a> Try Catch</h3> <p>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。 1.同步运行时错误：</p> <ol><li>同步错误</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">'foo'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nam<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获到异常：'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><code>捕获到异常： 'ReferenceError: nam is not defined at &lt;anonymous&gt;:3:15'</code></p></blockquote> <ol start="2"><li>语法错误</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> name <span class="token operator">=</span> 'foo
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nam<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获到异常：'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>Uncaught SyntaxError: Unexpected identifier</p></blockquote> <ol start="3"><li>异步错误</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">undefined</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> v<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获到异常：'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>Uncaught TypeError: Cannot read property 'map' of undefined</p></blockquote> <h3 id="window-onerror"><a href="#window-onerror" aria-hidden="true" class="header-anchor">#</a> window.onerror</h3> <p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {String}  message    错误信息
 * @param {String}  source    出错文件
 * @param {Number}  lineno    行号
 * @param {Number}  colno    列号
 * @param {Object}  error  Error对象（对象）
 */</span>
window<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">message<span class="token punctuation">,</span> source<span class="token punctuation">,</span> lineno<span class="token punctuation">,</span> colno<span class="token punctuation">,</span> error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获到异常：'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> message<span class="token punctuation">,</span> source<span class="token punctuation">,</span> lineno<span class="token punctuation">,</span> colno<span class="token punctuation">,</span> error <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>不同域名下的 js 报错不能被 全局的 window.onerror 监听到，我们需要给相关的 js 文件上加上 Access-Control-Allow-Origin:*的 response header，并且引用相关的 js 文件时加上 crossorigin 属性。相关<a href="https://www.jianshu.com/p/315ffe6797b8" target="_blank" rel="noopener noreferrer">文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p> <h3 id="window-addeventlistener"><a href="#window-addeventlistener" aria-hidden="true" class="header-anchor">#</a> window.addEventListener</h3> <p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的 window.addEventListener 捕获。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>./foo.png<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scritp</span><span class="token punctuation">&gt;</span></span>
window.addEventListener('error', (error) =&gt; {
    console.log('捕获到异常：', error);
}, true)
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="promise-catch"><a href="#promise-catch" aria-hidden="true" class="header-anchor">#</a> Promise Catch</h3> <p>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。</p> <p>或者可以全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。使用方式：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'unhandledrejection'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>当然你如果使用如 axios 这种库的话，错误处理完全可以放在它的请求实例里面做。更加的灵活。</p> <h3 id="vue-errorhandler"><a href="#vue-errorhandler" aria-hidden="true" class="header-anchor">#</a> VUE errorHandler</h3> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function-variable function">errorHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'通过vue errorHandler捕获的错误'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="react-异常捕获"><a href="#react-异常捕获" aria-hidden="true" class="header-anchor">#</a> React 异常捕获</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">componentDidCatch</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="崩溃和卡顿"><a href="#崩溃和卡顿" aria-hidden="true" class="header-anchor">#</a> 崩溃和卡顿</h3> <p><a href="https://zhuanlan.zhihu.com/p/40273861" target="_blank" rel="noopener noreferrer">相关文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://juejin.im/post/5cf72029f265da1b5f264334" target="_blank" rel="noopener noreferrer">实践总结】优雅的处理 vue 项目异常<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="insertbefore-坑"><a href="#insertbefore-坑" aria-hidden="true" class="header-anchor">#</a> insertBefore 坑</h2> <blockquote><p>2018-12-07</p></blockquote> <p>Node.insertBefore()很多人都用过， 它在参考节点之前插入一个节点作为一个指定父节点的子节点。</p> <p><code>var insertedNode = parentNode.insertBefore(newNode, referenceNode);</code></p> <p>但看文档还有一句补充说明：</p> <blockquote><p>如果 referenceElement 为 null 则 newElement 将被插入到子节点的末尾。如果 newElement 已经在 DOM 树中，newElement 首先会从 DOM 树中移除。</p></blockquote> <p>这就很坑了，如下面的例子：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>parentElement<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>bar<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>bar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>foo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">var</span> foo <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
  <span class="token keyword">var</span> bar <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
  <span class="token keyword">var</span> parentDiv <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'parentElement'</span><span class="token punctuation">)</span>
  parentDiv<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>原本以为结果是 <code>foo</code> <code>bar</code> <code>foo</code>，但实际结果是<code>foo</code> <code>bar</code>。</p> <p>因为根据文档，当你 insertBefore 的是一个已存在的值时，会移动它而不是拷贝它重新插入。贼坑！！！</p> <p>如果使用 ES6 的话可以使用 <code>before</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
bar<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>
</code></pre></div><h2 id="为什么前端监控要用-gif-打点"><a href="#为什么前端监控要用-gif-打点" aria-hidden="true" class="header-anchor">#</a> 为什么前端监控要用 GIF 打点</h2> <blockquote><p>2018-12-25</p></blockquote> <p>目前主流的前端监控数据上报都是采用 GIF 的上报方式，(百度统计/友盟/谷歌统计）都是这样实现的。但为什么一定要使用 GIF 呢？不能发 post 请求或者通过 script 标签的形式么？</p> <p>当然你也可以使用一些黑科技的方式上报，用纯 css 来实现。但这种方案并没有什么特别的好处。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.track-xx:active:after</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>track.php?xxxx=foo<span class="token punctuation">)</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="主要原因"><a href="#主要原因" aria-hidden="true" class="header-anchor">#</a> 主要原因</h3> <ul><li><p>没有跨域问题</p></li> <li><p>不会阻塞页面加载，影响用户体验</p></li> <li><p>在所有图片中体积最小，相较 BMP/PNG，可以节约 41%/35%的网络资源</p></li></ul> <p>详情见 <a href="https://mp.weixin.qq.com/s/v6R2w26qZkEilXY0mPUBCw" target="_blank" rel="noopener noreferrer">为什么前端监控要用 GIF 打点<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="使用方式"><a href="#使用方式" aria-hidden="true" class="header-anchor">#</a> 使用方式</h3> <p>但建议不要按如下方法使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'https://foo.com/bar.gif?t=xxxx&amp;b=1'</span>
</code></pre></div><p>这段代码的问题是这个 new Image()是一个没有引用的临时变量，随时可能被浏览器的垃圾回收机制回收。如果这个图片的 HTTP 请求尚未建立，那么在被回收时这个请求就会被取消，导致打点并没有真正发出。如果打点所在的页面比较复杂，浏览器垃圾回收机制可能会被频繁触发，那么这种方式打点的丢失率可能会高达 10%以上。</p> <p>解决方法很简单，将这个图片赋值给一个全局变量即可，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//加一个时间戳，防止图片被浏览器缓存了，不再发送请求</span>

window<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> img

img<span class="token punctuation">.</span>onload <span class="token operator">=</span> img<span class="token punctuation">.</span>onerror <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token function-variable function">onabort</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// img标签加载完成、错误或终止时，解除事件绑定，销毁相关对象</span>
  img<span class="token punctuation">.</span>onload <span class="token operator">=</span> img<span class="token punctuation">.</span>onerror <span class="token operator">=</span> img<span class="token punctuation">.</span>onabort <span class="token operator">=</span> <span class="token keyword">null</span>
  window<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span>
  img <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
img<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?t=key</span><span class="token template-punctuation string">`</span></span>
</code></pre></div><h3 id="其它方案"><a href="#其它方案" aria-hidden="true" class="header-anchor">#</a> 其它方案</h3> <p><code>Beacon API</code></p> <ul><li>在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行</li> <li>即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页</li> <li>能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理</li></ul> <p><code>navigator.sendBeacon(&quot;/log&quot;, analyticsData);</code></p> <h2 id="object-create-null-vs"><a href="#object-create-null-vs" aria-hidden="true" class="header-anchor">#</a> Object.create(null) vs {}</h2> <blockquote><p>2019.1.29</p></blockquote> <p>查看 vue 的源码 或者一些开源项目的源码，发现不少地方都是使用 <code>Object.create(null)</code>来创建一个空对象的。</p> <p>当使用语句 const obj = {}; 创建对象时，它其实并不是一个真的<code>空对象</code>，它从 Object.prototype 上继承了一些方法：</p> <ul><li>hasOwnProperty</li> <li>isPrototypeOf</li> <li>propertyIsEnumerable</li> <li>toString/toLocaleString</li> <li>valueOf</li></ul> <p><img src="https://wpimg.wallstcn.com/6b85bd8e-6b25-43e5-bb4f-67268ae364fb.jpg" alt="img"></p> <p>如果使用 <code>Object.create(null)</code> 创建的对象，在没有继承任何东西。
![img](https://wpimg.wallstcn.com/01845f8a-ee6b-4b15-88fb-b4a991b86523.jpg）</p> <p><strong>所以说是不是 <code>Object.create(null)</code> 是更好的创建一个空对象的方案呢？</strong></p> <p>这就要看从 Object 上继承的那些方法我们是不是有用到了。</p> <h3 id="hasownproperty"><a href="#hasownproperty" aria-hidden="true" class="header-anchor">#</a> hasOwnProperty</h3> <p>判断一个对象属性中是否具有指定的属性，返回 <code>true</code> or <code>false</code>。</p> <h3 id="valueof"><a href="#valueof" aria-hidden="true" class="header-anchor">#</a> valueOf</h3> <p>valueOf 很少直接使用。在隐式转换类型时，JavaScript 引擎会调用 valueOf 方法，强制把对象转换成原始值：</p> <h3 id="tostring、isprototypeof-和-propertyisenumerable"><a href="#tostring、isprototypeof-和-propertyisenumerable" aria-hidden="true" class="header-anchor">#</a> toString、isPrototypeOf 和 propertyIsEnumerable</h3> <p>这几个方法直接使用的情况较少，但自己的代码中不用并不表示别人写的代码不会调用。比如，有些框架可能会调用 toString 方法来判断结果是否为 [object Object]。</p> <h3 id="结论"><a href="#结论" aria-hidden="true" class="header-anchor">#</a> 结论</h3> <p>因此，我们可以得出结论：当创建的对象只在当前执行环境中使用并且不会用到任何从 Object.prototype 上继承来的方法，也不会将该对象作为其他对象的原型的时候，那么可以使用 Object.create(null)。比如，构造一个字典对象的时候。</p> <p>不过相对而言 <code>const obj={}</code>在浏览器中的执行速度是会比<code>Object.create(null)</code>快的，具体可点击链接<a href="https://jsperf.com/object-create-null-vs-literal/2" target="_blank" rel="noopener noreferrer">test<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。不过你一般代码中这些性能差距完全是可以忽略不计的。</p> <h2 id="async-await-with-foreach"><a href="#async-await-with-foreach" aria-hidden="true" class="header-anchor">#</a> async/await with forEach()</h2> <blockquote><p>2019-03-25</p></blockquote> <p>之前在工作中遇到了一个需求，实现一个简单的请求队列，大概意思就是这个页面有一个 list，我需要按 list 顺序依次发请求，多数据做一些操作，每次等前一个请求成功之后，再执行下一个，全部执行完毕之后，显示已完成。</p> <p>这不就是用 <code>async/await</code>就可以实现了。于是写了如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">waitFor</span> <span class="token operator">=</span> <span class="token parameter">ms</span> <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token parameter">num</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Done'</span><span class="token punctuation">)</span>
</code></pre></div><p>What？为什么<code>await</code>没有生效，直接就输出了<code>1,2,3</code>？谷歌搜索了一下，发现原来是<code>forEach</code>的锅。
我们简单来看一下 <code>forEach</code>的实现原理：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">forEach</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// this represents our array</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// We call the callback for each entry</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以看到它只是 for 循环的一个简单封装，而且在内部它只是简单做了一个回调，根本就不会<code>wait</code>。其实一些其它的数组方式比如<code>map</code>、<code>reduce</code>等等也是不支持的，因为 Array 的迭代方法就支持不支持参数函数返回 promise 的异步用法，有兴趣的可以自行了解。</p> <p>那我们直接用 <code>for</code>循环不就好了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>或者 <code>for-of</code>更为简单</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div> <h2 id="new-date-在-safari-的坑"><a href="#new-date-在-safari-的坑" aria-hidden="true" class="header-anchor">#</a> new Date 在 safari 的坑</h2> <p><code>new Date('2019-06-04 00:00:00')</code>在除了 Safari 的浏览器都能正常运行。
问题就出在 Safari 对于这个格式 <code>YYYY-MM-DD HH:MM:SS</code> 无法解析，所以我们需要做的是将其转化为 <code>YYYY/MM/DD HH:MM:SS</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>val<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/-/g</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="获取元素宽度"><a href="#获取元素宽度" aria-hidden="true" class="header-anchor">#</a> 获取元素宽度</h2> <p>说真的，我觉得前端麻烦的地方就是 API 太多了，我只是想获取一个元素的宽度居然有<code>getBoundingClientRect().width</code></p> <h2 id="我使用-async-await-而不使用-promises-的六个理由"><a href="#我使用-async-await-而不使用-promises-的六个理由" aria-hidden="true" class="header-anchor">#</a> 我使用 Async/Await 而不使用 Promises 的六个理由</h2> <p>本文主要来自于 <a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="noopener noreferrer">6 Reasons Why JavaScript’s Async/Await Blows Promises Away<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，在 medium 上，需要翻墙阅读。</p> <p>之前我很长一段时间内都是使用 promise 的，但遇到一些复杂业务的时候，发现还是写起来会很不爽，代码阅读性也有所欠缺。</p> <ol><li>简洁</li></ol> <p>对比 Promise，我们不需要书写.then，不需要新建一个匿名函数处理响应，也不需要再把数据赋值给一个我们其实并不需要的变量</p> <ol start="2"><li>a</li></ol> <p>但 Async/Await 也不是没有缺点的，很多人经常会错用它。比如我一个组件创建的的时候会异步向服务器发送三个请求，<code>a</code>、<code>b``、c</code>。
很多人会这么写</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> resultA <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> resultB <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> resultC <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span>

  <span class="token function">render</span><span class="token punctuation">(</span>resultA<span class="token punctuation">,</span> resultB<span class="token punctuation">,</span> resultC<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>虽然上面的这段写法相对于 promise 简洁了不少，但效率来说是不合格的。因为这个请求是异步的，毫无联系的，所有没必要顺序请求，他们三个明显可以异步并发的去请求。要想实现真正的异步，还是需要依赖 Promise.all 封装一层：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'a.json'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'b.json'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'c.json'</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">...</span>result<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>未完待续...</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/jian22446688/ele-alien/edit/master/docs/blog/js.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">10/16/2019, 9:39:50 AM</span></div></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/google-developer.html" class="prev">
          读谷歌开发指南
        </a></span> <span class="next"><a href="/blog/other.html">
          Other
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.baf443ff.js" defer></script><script src="/assets/js/37.ee884d88.js" defer></script>
  </body>
</html>
